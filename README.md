# ΑΝΑΦΟΡΑ ΠΡΟΓΡΑΜΜΑΤΙΣΤΙΚΗΣ ΑΣΚΗΣΗΣ Ι

## Γενικά
Σκοπός της πρώτης αυτής προγραμματιστικής άσκησης, όπως αναφέρθηκε και στην εφώνηση είναι η 
εξοικειωθη με την χρήση βασικών βιβλιοθηκών στοιχειωδών γραφικών της Opengl 3.3 (και μεταγενέστερων
εκδόσεων) οι οποίες υποστηρίζουν 2Δ και 3Δ γραφικά. 

## Τι πετύχαμε
Η παρακάτω λίστα χρησιμοποιήθηκε κατα την διάρκεια της ανάπτυξης του λογισμικού της άσκησης στο 
στο αποθετήριο του github.

* Task 1
  * - [x] Make the cube 100 X 100 cube 
  * - [x] Make cube transparent
  * - [x] random colour
  * - [x] black background
  * - [x] ESC to exit
* Task 2
  * - [x] Spacebar to spawn object
  * - [x] Make objects move
  * - [ ] Make objects collide
  * - [x] Random objects
  * - [ ] Include lighting
* Task 3
  * - [X] Create shpere 
  * - [x] Tranlate inside main cube
  * - [x] Make sphere move
* Task 4
  * - [x] Camera on all axis
* Task 5
  * - [x] Texture on sphere
  * - [x] Toggle texture (T button)
  
## Οδηγίες Εγκατάστασης
<!-- ΣΥΜΠΛΗΡΩΣΗ -->

## Οδηγείες χρήσης
<!-- ΣΥΜΠΛΗΡΩΣΗ -->

### Shaders
Οι shaders είναι υπεύθυνοι για την επικοινωνία μεταξύ του επεξεργαστή και της κάρτας γραφικών. Γράφοντας
 μικρά προγράμματα 
για τον vertex shader και τον fragment shader μπορούμε να καθορίσουμε την μορφή των αντικειμένων της 
σκηνής καθώς και το 
χρώμα τους.

### Έγγραφο .shader
Στην υλοποίηση μας χρησιμοποιούμε ένα αρχείο source code και για τους δύο shaders. Η απόφαση αυτή 
πάρθηκε, καθώς εξυπηρετούσε η ομαδοποίηση τους με αυτόν τον τρόπο. Η διαφοροποίηση τους επιτυγχάνεται 
με την επικεφαλίδα #shader και το είδος του shader (vertex, fragment αντίστοιχα). Περισσότερες
 λεπτομέρειες ως προς τον τρόπο ανάγνωσης δίνονται στην ενότητα ShaderProgram. 

Μέσα στον vertex shader περιέχονται τα εξής:

Αρχικά οι δύο μεταβλητές που περιέχονται μέσα σε όλα τα μοντέλα αντικειμένου 

vertexPosition_modelspace: πρόκειται για ένα vector 3 μεταβλητών και περιέχει τις συντεταγμένες 
 του αντικειμένου στο σύστημα συντεταγμένων local (model) space. 

vertexUV: πρόκειται για ένα vector 2 μεταβλητών και περιέχει τις συντεταγμένες του texture που είναι 
συνδεδεμένο με το αντικείμενο. 

Το vector vertexPosition χρησιμοποιείται μέσα στον vertex shader, ενώ το vertexUV ωθείται στον fragment 
shader.

Ο vertex shader επίσης περιέχει τα transformation matrices για κάθε σύστημα συντεταγμένων ως uniforms. 
To model matrix ορίζεται πριν από κάθε draw call ενός αντικειμένου και μετατρέπει τα local coordinates 
στο παγκόσμιο σύστημα συντεταγμένων.
Έπειτα, το view matrix το οποίο ανανεώνεται μετά από κάθε αλλαγή της κάμερας, μετατρέπει τις 
συντεταγμένες από το παγκόσμιο σύστημα στο οπτικό σύστημα συντεταγμένων (που ακριβώς είναι το αντικείμενο 
ως προς την κάμερα). 

Τέλος, το projection matrix (στο οποίο χρησιμοποιούμε προοπτική όψη) εξυπηρετεί 2 σκοπούς. Ο πρώτος είναι
 να καθορίζει πόσο μακριά και πόσο κοντά στην κάμερα μπορούμε να δούμε και ο δεύτερος είναι τα 
 αντικείμενα όσο απομακρύνονται από την κάμερα να μικραίνουν (αποτέλεσμα της προοπτικής όψης), το οποίο 
 μας δίνει στην αίσθηση ότι κοιτάμε τρισδιάστατα αντικείμενα.

Εξήγηση της εξίσωσης του fragment shader (μπαίνει εδώ)

 
### Η κλάση ShaderProgram
Η κλάση αυτή είναι υπεύθυνη για την υλοποίηση ενός «διαμεσολαβητή» μεταξύ των shaders και του 
επεξεργαστή, που χρησιμοποιούμε κυρίως για τον ορισμό των transformation matrices.
Για την αρχικοποίηση του προγράμματος διαχείρησης των shaders, περνάμε στον constructor την διαδρομή προς
τον χώρο που είναι αποθηκευμένο το αρχείο .shader. Εσωτερικά της κλάσης υπάρχει μια δομή 
shaderProgramSource (στο header της κλάσης), η οποία αποτελείται από δύο string το VertexShaderSource
και το FragmentShaderSource όπου και αποθηκεύουμε τον πηγαίο κώδικα του κάθε shader. 
H διαδικασία για την κατασκευή ένος shader program είναι η εξής:

1. Mέσα στην μέθοδο Parse shader γίνεται η ανάγνωση του αρχείου .shader. Όταν το πρόγραμμα διαβάζει την
  επικεφαλίδα #shader vertex/fragment γνωρίζει ότι ο ακόλουθος κώδικας έχει να κάνει με τον shader που 
  ορίζει η επικεφαλίδα και σώζει τον κώδικά του στο αντίστοιχο string.

2. Έχοντας λάβει τα sources και των δύο shaders, περνάμε μέσα στην μέθοδο create shaders που είναι
  υπεύθυνη για την δημιουργία του αντικειμένου shaderProgram. Για να δημιουργήσει όμως το αντικείμενο 
  πρέπει πρώτα να γίνει η μετάφραση των δύο shaders. Αυτό αποτελεί ευθύνη της μεθόδου compileShader.

3. Η μέθοδος compileShader λαμβάνει το είδος του shader που πρόκεται να μεταφραστεί (ορισμένες από την
  openGL ως GL_VERTEX_SHADER και GL_FRAGMENT_SHADER). Η μέθοδος στην συνέχεια χρησιμοποιεί τις μεθόδους
  της openGL για την δημιουργία του shader που θέλουμε. Αν υπάρξει κάποιο σφάλμα κατά την μετάφραση η 
  μέθοδος εμφανίζει ένα μήνυμα λάθους. Όταν ολοκληρωθεί η διαδικασία αυτή, η μέθοδος θα επιστρέψει ένα
  GLuint που αντιπροσωπεύει πλέον τον δημιουργημένο shader.

4. Το βήμα 3 πραγματοποιείται 2 φορές, μια για κάθε shader. Έπειτα η ροή επιστρέφει στην create shader,
  η οποία δεσμεύει τους δύο shaders με το πρόγραμμά μας και καταστρέφει τους εικονικούς shaders, 
  αποδεσμεύοντας έτσι μνήμη.

5. Στο τέλος αυτής της διαδικασία έχουμε κρατήσει μια μεταβλητή GLuint, η οποία περιέχει το ID του 
  προγράμματος με το οποίο έχουμε δεσμεύει τους δύο shaders.

Άλλες λειτουργίες που εκτελεί η κλάση αυτή είναι ο ορισμός των uniforms που περιέχονται μέσα στον vertex
shader, 1 για κάθε είδους uniform που χρησιμοποιούμε. 
Εσωτερικά της κλάσης υπάρχει και η μέθοδος getUniformLocation η οποία επιστρέφει ένα GLint με την τοποθεσία της μεταβλητής του shader που 
επιθυμούμε να χρησιμοποιήσουμε.
Τέλος, η μέθοδος getAttribLocation βοηθάει τον καθορισμό του layout των vertex buffer των αντικειμένων επιστέφοντας την τοποθεσία των δύο μεταβλητών που λαμβάνει ο vertex shader απευθείας από τα αντικείμενα.

Για την υλοποίηση του ShaderProgram έγινε αναφορά στο εξής βίντεο:
Shader Abstraction in OpenGL από το κανάλι The Cherno


## Ερώτημα 1
<!-- ΣΥΜΠΛΗΡΩΣΗ -->

## Ερώτημα 2
<!-- ΣΥΜΠΛΗΡΩΣΗ -->

## Ερώτημα 3
Για την κίνηση της σφαίρας υπάρχουν δύο παγκόσμιες μεταβλητες στο header file Application.h, η πρώτη
είναι το vec3 sphereControl η οποία καθορίζει την κατεύθυνση της κίνησης της σφαίρας, και η μεταβλητή
 SPH_speed που ορίζει την ταχύτητα, δηλαδή την απόσταση της κάθε μετατόπισης.

Κάθε φορά που το παράθυρο λαμβάνει ως event το πάτημα ενός κουμπιόυ από τα βελάκια ή το + - του numbpad
 ενός πληκτρολογίου, μεταβάλουμε την μεταβλητή sphereControl κατάλληλα, και μεταβάλλουμε το model Matrix
  της σφαίρας πριν από κάθε draw call της SPH. 

Μενού κίνησης
Τα βελάκια του πληκτρολογίου κινούν την σφαίρα στους άξονες x,y με κατεύθυνση ίδια με αυτή που δηλώνουν
Το + κινεί την σφαίρα προς τα θετικά του άξονα z, το οποίο έχει κατεύθυνση προς τον χρήστη
Το – κινεί την σφαίρα προς τα αρνητικά του άξονα z, δηλαδή μακριά από τον χρήστη.


## Ερώτημα 4

### Κάμερα
Η δημιουργία και η διαχείριση της κάμερας γίνετε μέσα από την κλάση Camera.
Για την αρχικοποίηση της απαιτούνται η αρχική της θέση (position) που εκφράζει την θέση του
ματιού καθώς και ο ορισμός του πάνω μέρους (worldUp).
Προκειμένου να μπορούμε να εναλλάσσουμε το οπτικό πεδίο της κάμερα μας ανανεώνουμε
συνεχώς την αντίστοιχη τιμή view που είναι υπεύθυνη. Αυτό συμβαίνει μέσα στην κλάση της
κάμερας με την μέθοδο calculateViewMatrix() .
Εκεί η LookAt() δέχεται ως εξής τις παραμέτρους της αρχικής θέσης κάμερας, τον ‘’στόχο’’ προς
τον οποίο θα κοιτάει και το πάνω μέρος.
Ο ‘’στόχος’’ μας παραμένει συνέχεια σταθερός και είναι το κέντρο του κύβου (50,50,50) όπως
αντίστοιχα και το πάνω μέρος(worldUp). Αυτό που εναλλάσσουμε συνεχώς είναι η θέση της
κάμερας. Η αρχική θέση της κάμερας είναι στο (50,50,250).
Κατά το zoomIn αλλάζουμε την θέση της κάμερας με την βοήθεια μιας σταθεράς που την
έχουμε ορίσει έπειτα από δοκιμές προκειμένου να μπορεί να είναι όσο πιο ομαλή η κίνηση
αυτή της κάμερας. Αντίστοιχα και για το ZoomOut. Έτσι αλλάζουμε την θέση της κάμερας ώστε
να την μεταφέρουμε πιο κοντά και μακριά αντίστοιχα.
Όσον αφορά τις περιστροφές που θα κάνει η κάμερα αυτές γίνονται με την βοήθεια του
quaternion. Σε κάθε μία από τις περιστροφές που έχουμε επιλέγουμε η κάθε περιστροφή να
γίνετε γύρω από έναν άξονα (x και y αντίστοιχα). Εκεί επιλέγουμε την θετική και αρνητική
γωνία που θα μας επιτρέψει να κάνουμε την δεξιόστροφή και αριστερόστροφη αντίστοιχα
περιστροφή. Η επιλογή της γωνίας αντίστοιχα έγινε έπειτα από δοκιμές στην περισσότερη
επιθυμητή περιστροφή για εμάς.
Κατά την περιστροφή γύρω από έναν άξονα θεωρώντας ως κέντρο τον κύβο μας η θέση της
κάμερας δεν ανήκει σε έναν κύκλο με σταθερή ακτίνα. Συνεπώς υπάρχουν σημεία που η
κάμερα μας θα περιστρέφεται όπως επιθυμούμε κανονικά γύρω από τον αντίστοιχο άξονα
αλλά θα μεγεθύνεται ή θα μικραίνει το πλάνο πατώντας μόνο το αντίστοιχο πλήκτρο
περιστροφής. Με την χρήση των πλήκτρων για ZoomIn [Ε] και ZoomOut[W] ο χρήστης είναι σε
θέση να επιλέξει κάθε φορά ανάλογα την εστίαση η απομάκρυνση αν θέλει να φτιάξει το
πλάνο του. Έτσι έχει την δυνατότητα να εναλλάξει τις γωνίες από τις οποίες θα βλέπει τον
κύβο και τα αντικείμενα του.
Όσον αφορά τα πλήκτρα που επιτρέπουν τις παραπάνω κινήσεις είναι:
W: rotate x positive
S: rotate x negative
A: rotate y positive
D: rotate y negative
E: zoom in
X: zoom out
Πηγή: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#qua

## Ερώτημα 5  

Γιά την φόρτωση των κατάλληλων δεδομένων του texture ακολουθήσαμε το tutorial του 
[learnopengl.com](https://learnopengl.com/Getting-started/Textures) το οποίο προτέινει την χρήση
του header `stb_image.h`. Συμπεριλάβαμε την μέθοδο `loadTexture()` η οποία χρησιμοποιέι την `stbi_load` 
και φορτώνει τα δεδομένα της εικόνας στην openGl ωστε να χρησιμοποιηθούν ως texture. Η μέθοδος
αυτή καλέιται στο `main.cpp` κατα την αρχικοποίηση των παραμέτρων της σφαίρας στην μέθοδο `initSPΗ`. 

H πληκτρολόγηση του πλήκτρου 'T' εντοπίζεται απο το events της openGL όπως ορίστικε στη 
`glfwSetKeyCallback` στην μέθοδο `InitWindow`.Η μέθοδος `key_callback` καλεί την `switchTexture()`
στο αντικείμενο `Object SPH_sphere` ώστε να δηλωθεί οτι θέλουμε να ενεργοποιήσουμε το texture της.  

```c++
void Object::switchTexture()
{
    enableTexture = !enableTexture;
    std::cout << "$Obj :: EnableTexture set to: " << enableTexture << "\n";
}
```

Στην συνέχεια χρησιμοποιήσαμε το `uniform transparency`, με τον τρόπο που εξηγήθηκε παραπάνω, και τελικά 
ενεργοποιούμε το shader που φορτώσαμε στην SPH sphere οταν η μεταβλητή `enableTexture` είναι true
διαφορετικά το texture απενεργοποιείται και ενεργοποιείται το χρώμα της σφάιρας.  

```c++
void drawSPH(Object& SPH_sphere, ShaderProgram& shaderProgram)
{
	SPH_sphere.bindVAO();
	shaderProgram.setUniform1f("transparency", 1.0f);
	// TODO: built this if into a function?
	if (SPH_sphere.enableTexture)
	{
		shaderProgram.setUniform4f("textureFlag", 1.0f, 1.0f, 1.0f, 1.0f);
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, SPH_sphere.texture);
	}
	else {
		shaderProgram.setUniform4f("textureFlag", 0.0f, 0.0f, 0.0f, 0.0f);
		shaderProgram.setUniform3f("set_color", SPH_sphere.color[0], SPH_sphere.color[1], SPH_sphere.color[2];
	}

	SPH_sphere.moveObject(sphereControl);
	shaderProgram.setUniform4fv("model_matrix", 1, GL_FALSE, glm::value_ptr(SPH_sphere.modelMatrix));
	glDrawArrays(GL_TRIANGLES, 0, SPH_sphere.m_vertices.size());
	glBindTexture(GL_TEXTURE_2D, 0);
	SPH_sphere.unbindVAO();
}
```

Μπορείτε και εσείς να χρησιμοποιήσετε τα textures που δοκιμάσαμε δίνωτας η δικά σας ορίζωντας 
το σωστο path στην `loadTexture(PATH)` στην `initSPH`. Τα textures μας βρίσκονται στον φάκελο
`\res\textures`.  


